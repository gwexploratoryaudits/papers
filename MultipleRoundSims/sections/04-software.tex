%Software
In this section we describe the software implementing ballot polling audits and the simulator, termed the R2B2 library. All the software is released as open source under the MIT License.
\subsection{R2B2 Library}

The R2B2 Python library provides a framework for the exploration of round-by-round
and ballot-by-ballot Risk-Limiting Audits (RLAs). The goal in designing R2B2 is two fold:
\begin{enumerate}
    \item Provide an elegant Python library which can be easily imported and used
    in any other code base.
    \item Provide an interactive set of tools which can be utilized `out-of-the-box'
    for experimenting with and learning about risk-limiting audits.
\end{enumerate}
The following describes the design, usage and possible next steps for the R2B2 library.

\subsection{Design}

The high-level design of R2B2 is an object-oriented view of election audits.
The three main object classes, \code{Election}, \code{Contest}, and \code{Audit},
-serve to group data into logically independent structures.

\subsubsection{Election}
The \code{Election} contains the information that comprises an entire election,
most importantly, the total number of ballots cast in the election and the list
of \code{Contest}s from the election. At the moment \code{Election} does not offer
functionality beyond grouping \code{Contest}s; potential functionality discussed
in 1.3 Future Work.

\subsubsection{Contest}
The \code{Contest} contains the information related to a single
contest such as the ballots cast in that contest, the candidates, the type of contest,
and the reported tally. Providing a structure to hold this information independent of
any particular audit is especially useful for exploratory work.

\subsubsection{Audit}


The \code{Audit} contains information related to a single contests audit parameters
such as the risk limit, sampling method, and \code{Contest} to audit. It is important
to note the \code{Audit} is an Abstract Base Class upon which specific RLAs are built.
It only contains the parameters and attributes common to all RLAs and provides a set
of methods that can be called by any audit implementation. The functionality of
\code{Audit} can be divided into two basic groups: \textit{interactive}
and \textit{bulk}.\\
\\
The interactive implementation allows users to execute an audit step-by-step as it
might progress during a live election audit through the following:

\begin{itemize}
    \item The \code{run()} method begins an interactive audit executing where users
    are prompted for round sizes and the counts of winner ballots found in the sample
    and in return are given information about the current state of the audit and whether
    the stopping condition(s) have been met.
    \item Two distributions representing the null and alternative hypotheses are maintained
    and allow for computation of the audits per-round risk and stopping probability
    schedules.
    \item Before each round, the audit will recommend possible next round sizes given
    different criteria, such as a set of desired stopping probabilities.
\end{itemize}
The bulk implementations allows users to generate a larger set of data from an audit
such as:

\begin{itemize}
    \item A set of stopping conditions given a set of round sizes.
    \item A set of risk levels given a set of round size and winner ballots pairs.
    \item A list of all stopping conditions from the minimum to the maximum round size.
\end{itemize}

\subsection{Usage}

R2B2 makes understanding and exploring election audits simple for the user with no
Python knowledge while simultaneously providing a comprehensive set of tools for
the experienced Python developer.

\subsubsection{Python Library}

Using R2B2 is as simple as using any other Python library: simply import the library
and all of the functionality is at your finger tips. Not only does this allow users
to write their own Python scripts for exploring RLAs, it also allows R2B2 to be plugged
in to any other Python library. See the following Jupyter Notebooks for information on
the usage of R2B2:

\begin{itemize}
    \item \href{https://github.com/gwexploratoryaudits/r2b2/blob/notebooks/notebook/R2B2%20Basics.ipynb}{Basic Usage}
    \item \href{https://github.com/gwexploratoryaudits/r2b2/blob/notebooks/notebook/Generating%20Graphs.ipynb}{Generating Graphs}
\end{itemize}


\subsubsection{Stand-Alone Tool}

R2B2 provides a significant amount of functionality `out-of-the-box' for educational
or exploratory use. For those who wish learn about RLAs without having to write any
code themselves, R2B2 provides a command line tool for both interactive auditing and
generating audit results and statistics for larger data sets.

\subsection{Simulations to Support Theoretical Audit Properties}

The outcomes of RLAs depend on random chance; some random samples
support the alternative hypothesis more than expected, resulting in 
quick low-risk conclusions, while other samples require subsequent
rounds in order to confirm the announced results.
We can simulate random samples for various underlying ballot 
distributions by computing pseudorandom samples. 
By applying an audit's stopping condition to thousands of such
simulated samples, the average behavior of the simulated
audits will tend towards the true behavior of the audit.
In this way, we can examine whether theoretical claims about an audit are
actually correct.

\subsection{Software for Simulations}
Our open source audit software library r2b2 [link] has implementations of several ballot polling risk-limiting audits as well as a simulator, 
all written in Python.
For each of these audits, the software can evaluate the stopping condition for a given sample and can give estimates
of the minimum round size to achieve a desired stopping probability. 
For a given audit and random seed, the simulator draws random samples using the pseudorandom number generator, [need to check].
Ballots can be sampled from any distribution of the users choosing. 
It is often useful to consider the distribution of ballots corresponding to a tie and the 
distribution of ballots corresponding with the announced results; these are the distributions represented
by the null and alternative hypotheses.
After drawing a sample, the simulator then evaluates the given audit's stopping condition for this simulated sample.
If the audit stops, the simulation stops, and if the audit continues, the simulation draws another round. 
The abstract simulator class does not prescribe any one method for choosing round sizes. 
We implement several classes to support various round size choices: 
round sizes from an estimate to achieve a desired probability of stopping, 
predetermined round sizes, and random round sizes. 

